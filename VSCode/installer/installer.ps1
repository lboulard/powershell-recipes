$ErrorActionPreference = "Stop"

$nameRegex = "^VSCode-win32-x64-(?<version>\d+\.\d+\.\d+)\.zip$"

$folderRegex = "^(?<version>\d+\.\d+\.\d+)$"
$root = Join-Path (Get-Location) ".." -Resolve

# folders ordered by version string
$folders = Get-ChildItem $root -Directory | Where-Object {
  $_.Name -match $folderRegex
} | Sort-Object -Unique -Descending -Property {
  if ($_.Name -match $folderRegex) {
    $Matches.version -as [version]
  }
}

if (-not $folders) {
  throw "no folder versions found"
}

$lastVersion = $folders[0]

# sort again, but from filename pattern
$files = $lastVersion | Get-ChildItem -File | Where-Object {
  if ($_.Name -match $nameRegex) {
      $_
  }
}

if (-not $files) {
  throw "no file versions found"
}

$archive = $files[0]
if ($archive.Name -match $nameRegex) {
  $archiveVersion = [version]$Matches.version
  if (-not ($archiveVersion -eq $lastVersion.Name)) {
    Write-Warning "${archive}: does not match last version ${lastVersion} (found $($Matches.version))"
  }
}

$name = $archive.Name
$basename = $archive.BaseName
$dest = "files-${ArchiveVersion}"

# expand and after verification of top folder name, install in final destination
if (-not (Test-Path $dest)) {
  Write-Host ":: " -NoNewline
  Write-Host "Expand ${name} to ${dest}\" -ForegroundColor Yellow
  Expand-Archive -DestinationPath $dest -LiteralPath $archive.FullName -Force
} else {
  Write-Host ":: " -NoNewline
  Write-Host "${basename}: already found in ${dest}\" -ForegroundColor Green
}

@(
  "// autogenerated"
  "#define VSCodeVersion `"${archiveVersion}`""
  "[Setup]"
  "SourceDir=$(Get-Location)"
) -join "`n" | Set-Content -Path "version.inc.iss" -Encoding UTF8 -Force
